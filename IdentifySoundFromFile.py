# -*- coding: utf-8 -*-
"""Trial4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1gIjJbEVAklEyH0UEKcqUtbQC1VrNF62g
"""

#!pip install sounddevice
#!apt-get install -y python3-pyaudio
#!apt-get install -y portaudio19-dev
#!pip install pyaudio

import os
import numpy as np
import librosa
from scipy.fft import fft
import sounddevice as sd

sounds = {
    'doorbell': './doorbell/doorbell-1.wav',
    'dog barking': './dogbarking/bark-1.wav',
    'door knock': './doorknock/door-knock-2.wav'
}

sr = 22050
duration = 2  # seconds
n_fft = 2048
hop_length = 512
fft_dict = {}

# Loop through each sound and compute the FFTs for each window
for sound, path in sounds.items():
    y, _ = librosa.load(path, sr=sr)
    fft_list = []
    
    # Compute the FFT for each window in the audio file
    for i in range(0, len(y)-n_fft, hop_length):
        y_win = y[i:i+n_fft]
        fft_win = np.abs(fft(y_win))
        fft_list.append(fft_win)
    
    fft_dict[sound] = fft_list

def identify_sound(y):
    # Compute the FFTs for each window in the new audio clip
    fft_list = []
    for i in range(0, len(y)-n_fft, hop_length):
        y_win = y[i:i+n_fft]
        fft_win = np.abs(fft(y_win))
        fft_list.append(fft_win)
    
    # Calculate the mean FFT for each sound in the training data
    mean_ffts = {}
    for sound, ffts in fft_dict.items():
        mean_fft = np.mean(ffts, axis=0)
        mean_ffts[sound] = mean_fft
    
    # Calculate the correlation between the mean and the new audio clip
    correlations = {}
    for sound, mean_fft in mean_ffts.items():
        corr = 0
        for fft_win in fft_list:
            corr += np.corrcoef(mean_fft, fft_win)[0, 1]
        corr /= len(fft_list)
        correlations[sound] = corr
    
    # Identify the sound with the highest correlation
    identified_sound = max(correlations, key=correlations.get)
    
    return identified_sound

def file(filename):
    y, _ = librosa.load(filename, sr=sr)
    
    # Convert the audio to a mono signal and normalize it
    y = librosa.to_mono(y)
    y /= np.max(np.abs(y))
    
    identified_sound = identify_sound(y)
    print('Identified sound:', identified_sound)

# Main
file('./test/dk.wav')
file('./test/db.wav')
file('./test/bark.wav')